### 0. 개요
- 테스트에서 mock을 사용하는 것은 논란의 여지가 있는 주제라고 함
- 이 챕터에서 런던파와 고전파의 논쟁을 집중적으로 다룬다고 함

### 1. mock과 stub 구분
- 테스트 대역
  - `테스트 대역(스턴트맨)`은 가짜 의존성을 지칭하는 포괄적인 용어
  - 테스트 대역의 주 용도는 테스트를 편리하게 하는 것
  - mock과 stub 차이?
    - mock은 SUT와 관련 의존성의 `상호 작용을 모방`  
      SUT -> 관련 의존성으로 나가는 상호 작용을 모방하고 검증?
    - stub은 (상태만?) 모방?  
      관련 의존성 -> SUT 내부로 들어오는 상호 작용을 모방만 한다?
- 도구로서의 mock과 테스트 대역으로서의 mock?
  - mock이라는 용어는 특정 타입의 테스트 대역을 지칭하기도 하고, mock 라이브러리 도구를 지칭하기도 함
- 스텁으로 상호 작용을 검증하지 말라?
  - `과잉명세`? : 최종 결과가 아닌 사항을 검증하는 것을 지칭

- mock과 stub 개념은 CQS 원칙과 관련이 있다?
  - 명령을 대체하는 테스트 대역은 mock이고, 조회를 대체하는 테스트 대역은 stub이다?
    ```java
    // 명령. mock
    var mock = mock(...);
    verify(mock).someAction();
    
    // 조회. stub
    var stub = mock(...);
    when(stub.get(...)).thenReturn(...);
    ```

### 2. 식별할 수 있는 동작과 구현 세부 사항?
- 테스트 취약성을 유발하는 원인
  - 테스트 취약성은 `리팩터링 내성`을 지칭하는 거라고 함
  - false positive의 원인은 주로 테스트 코드가 `구현 세부 사항`과 결합되기 때문이었다고 함  
    즉, 테스트가 ~~어떻게~~가 아니라 `무엇`에 중점을 둬야 한다고 함
  - 제품 코드의 분류
    - 식별할 수 있는 동작 vs 구현 세부 사항
      - 식별할 수 있는 동작은 클라이언트에게 도움이 되는 연산이나 상태를 노출하는 것. 
    - 공개 API와 비공개 API
    - 구현 세부 사항이 공개 API로 노출되면 문제..  
      `캡슐화` 잘 하라고 함..  
       캡슐화는 궁극적으로 단위 테스트와 동일한 목표를 달성한다고 함
    - **결론!!**
      - 모든 `구현 세부 사항`을 비공개로 하면, 테스트가 `식별할 수 있는 동작`을 검증하는 것 외에는   
        다른 선택지가 없어지며, 이로 인해 `리팩터링 내성`도 자동으로 좋아진다는 논리!!

