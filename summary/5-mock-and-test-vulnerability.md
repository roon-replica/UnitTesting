### 0. 개요
- 테스트에서 mock을 사용하는 것은 논란의 여지가 있는 주제라고 함
- 이 챕터에서 런던파와 고전파의 논쟁을 집중적으로 다룬다고 함

### 1. mock과 stub 구분
- 테스트 대역
  - `테스트 대역(스턴트맨)`은 가짜 의존성을 지칭하는 포괄적인 용어
  - 테스트 대역의 주 용도는 테스트를 편리하게 하는 것
  - mock과 stub 차이?
    - mock은 SUT와 관련 의존성의 `상호 작용을 모방`  
      SUT -> 관련 의존성으로 나가는 상호 작용을 모방하고 검증?
    - stub은 (상태만?) 모방?  
      관련 의존성 -> SUT 내부로 들어오는 상호 작용을 모방만 한다?
- 도구로서의 mock과 테스트 대역으로서의 mock?
  - mock이라는 용어는 특정 타입의 테스트 대역을 지칭하기도 하고, mock 라이브러리 도구를 지칭하기도 함
- 스텁으로 상호 작용을 검증하지 말라?
  - `과잉명세`? : 최종 결과가 아닌 사항을 검증하는 것을 지칭

- mock과 stub 개념은 CQS 원칙과 관련이 있다?
  - 명령을 대체하는 테스트 대역은 mock이고, 조회를 대체하는 테스트 대역은 stub이다?
    ```java
    // 명령. mock
    var mock = mock(...);
    verify(mock).someAction();
    
    // 조회. stub
    var stub = mock(...);
    when(stub.get(...)).thenReturn(...);
    ```

### 2. 식별할 수 있는 동작과 구현 세부 사항?
- 테스트 취약성을 유발하는 원인
  - 테스트 취약성은 `리팩터링 내성`을 지칭하는 거라고 함
  - false positive의 원인은 주로 테스트 코드가 `구현 세부 사항`과 결합되기 때문이었다고 함  
    즉, 테스트가 ~~어떻게~~가 아니라 `무엇`에 중점을 둬야 한다고 함
  - 제품 코드의 분류
    - 식별할 수 있는 동작 vs 구현 세부 사항
      - 식별할 수 있는 동작은 클라이언트에게 도움이 되는 연산이나 상태를 노출하는 것. 
    - 공개 API와 비공개 API
    - 구현 세부 사항이 공개 API로 노출되면 문제..  
      `캡슐화` 잘 하라고 함..  
       캡슐화는 궁극적으로 단위 테스트와 동일한 목표를 달성한다고 함
    - **결론!!**
      - 모든 `구현 세부 사항`을 비공개로 하면, 테스트가 `식별할 수 있는 동작`을 검증하는 것 외에는   
        다른 선택지가 없어지며, 이로 인해 `리팩터링 내성`도 자동으로 좋아진다는 논리!!

### 3. 목과 테스트 취약성 사이의 관계
- 헥사고날(육각형) 아키텍처, 내부/외부 통신, 목과 테스트 취약성 간의 관계에 대한 내용
- 육각형 아키텍처
  - 도메인 계층, 애플리케이션 서비스 계층으로 구분하여 관심사 분리    
    도메인 계층은 비즈니스 로직을 포함, 애플리케이션 서비스 계층은 외부 환경과의 통신을 조정
  - 시스템 내부 통신과 시스템 간 통신
    - 내부 클래스 간의 협력과 달리 외부 환경과 통신하는 방식은 해당 시스템의 식별할 수 있는 동작을 나타낸다고 함
    - **mock을 사용하면 외부 애플리케이션과의 통신 패턴을 확인할 때 좋다고 함.  
      하지만 내부 클래스 간 통신을 검증할 때 mock을 사용하면 구현 세부 사항과 결합되어 리팩터링 내성이 낮아짐!!**
    - 예를 들어, 구매라는 유스케이스에서 구매 후 고객에게 메일 전송은 외부 시스템과의 통신, 구매 후 내부 레포지토리의 수량 감소는 내부 시스템 통신

### 4. 단위 테스트의 고전파와 런던파(mockist) 재고
- 런던파는 어떤 상황이든 목을 무분별하게 사용하므로 저자는 고전파가 낫다고 함  
  근데 고전파도 목을 많이 장려해서 문제인데, 시스템간 통신의 경우에만 mock을 쓰라고 말함
- 예외
  - 외부에서 관찰할 수 없는 프로세스 외부 의존성은 애플리케이션의 일부로 작용해서 mock 쓰지 말라고 함
    - 클라이언트의 시야에서 완전히 숨겨져있기 때문에? 애플리케이션에서만 사용되는 데이터베이스가 그렇다고 함..  
- 동작을 검증한다고 목을 써야하는 건 아니라고 함  
  중요한 건 `클라이언트의 요구사항을 수행하는 동작`이고, 이러한 검증을 할 때 외부환경을 목으로 대체 가능한거라고 함..